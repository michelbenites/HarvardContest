---
title: "Harvard DS Animation Contest"
author: "Michel Benites Nascimento"
date: "29 de dezembro de 2018"
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(plotly)
knitr::opts_chunk$set(echo = TRUE)
```

**Scale command / Z Distribuition**

The main purpose here is to show how the scale command works in a dataset. In statistics it is very important to transform the data in Z-scale before analyzing them, thus obtaining a normalization of the dataset. When you have data of different magnitudes, for instance kilometers, seconds, temperature etc. makes all sense converts them into a more homogenous distribution facilitating the analysis and the input of these data in some algorithms.
Graphically I'm showing a dataset that was created in a random way that is gradually being staggered (steps of 10%). Initially we have for the X axis values between -5 and 5 and for Y values between -25 and 25. At the end of the procedure of scaling the dataset, we will have both X and Y values between -2 and 2, without losing the proportionality.
```{r randomdataset}
# Generating random dataset
x <- runif(1000,  -5, 5)
y <- runif(1000, -25, 25)
z <- runif(1000,   1, 2)

# Transforming in a data frame
sim.data       <- data.frame(cbind(x,y,z))

# Creating a complete data frame with all stage of scales
sim.data.total        <- sim.data
sim.data.total$pscale <- 0

# Steps of 10%
ntry <- 1:10
sim.part <- NULL
for (i in ntry) {
  
  # define the part (start and end) of the dataset to take
  end.r        <- 100 * i
  ini.r        <- end.r - 99
  sim.part     <- data.frame(rbind(sim.part, scale(sim.data[ini.r:end.r,])))
  
  # Scale only one part of the dataset
  if ((end.r)<nrow(sim.data)) {
    sim.data.scl <- data.frame(rbind(sim.part, sim.data[(end.r+1):nrow(sim.data),]))
  } 
  # if end.r < nrow(sim.data) scale full dataset
  else {
    sim.data.scl <- data.frame(scale(sim.data))
  }
  
  sim.data.total <- rbind(sim.data.total, data.frame(x=sim.data.scl$x, y=sim.data.scl$y, z=sim.data.scl$z, pscale=i*10))
    
}

```

```{r animationchart}
# Store in p variable the ggplot object
p <- ggplot(sim.data.total, aes(x=x, y=y, color=z)) + geom_point(aes(frame = pscale)) + ggtitle("Scaling the Dataset") + theme(plot.title = element_text(hjust = -5, vjust=0))

# Animate the ggplot object with ggploty
ggplotly(p) %>% animation_opts(1000) %>% animation_slider(currentvalue = list(prefix = "Scale ", posfix = "%", font = list(size=12, color="red")))  %>% config(displayModeBar = F)
```

**Session info**
For reproducibility purposes it is always a good idea to capture the state of the environment that was used to generate the results:

```{r}
sessionInfo()
```
